<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Alpha-Shape</title>
</head>
<body>
<!--<script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>-->
<!--<script src="https://cdn.jsdelivr.net/npm/alpha-shape@1.0.0"></script>-->
<!--<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>-->
<!--<script src="js/main.js" type="module"></script>-->
<!--<canvas id="myCanvas" width="200" height="100"></canvas>-->
<div id="app"></div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script >

    const w = window.innerWidth;
    const h = (w * 9) / 16;
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d"); // DOM.context2d(width, height);
    //const context2 = canvas.getContext("2d"); // DOM.context2d(width, height);

    canvas.width = w;
    canvas.height = h;

    const data = Array(100)
        .fill()
        .map((_, i) => ({ x: (i * w) / 100, y: Math.random() * h }));

    let delaunay = d3.Delaunay.from(
        data,
        (d) => d.x,
        (d) => d.y
    )

    context.clearRect(0, 0, w, h);

    context.fillStyle = "black";
    context.beginPath();
    delaunay.renderPoints(context,2)

    delaunay.render(context)

    context.stroke();

    function alphashapefilter(delaunay, alpha) {
        const asq = alpha ** 2;
        function dist2(p, q) {
            return (
                (delaunay.points[2 * p] - delaunay.points[2 * q]) ** 2 +
                (delaunay.points[2 * p + 1] - delaunay.points[2 * q + 1]) ** 2
            );
        }
        return function(i) {
            let t0 = delaunay.triangles[i * 3 + 0],
                t1 = delaunay.triangles[i * 3 + 1],
                t2 = delaunay.triangles[i * 3 + 2];
            return dist2(t0, t1) < asq && dist2(t1, t2) < asq && dist2(t2, t0) < asq;
        };
    }


    let alpha = 500;

    // let a = alpha*alpha

    let filter = alphashapefilter(delaunay, alpha)
    // let alphashape = new Uint8Array(delaunay.triangles.length / 3).map((_, i) => filter(i))
    let alphashape = new Uint8Array(delaunay.triangles.length).map((_, i) => filter(i))

    //console.log(alphashape)

    function boundary(delaunay, members) {
        const counts = {},
            edges = {},
            result = [];
        let r;

        // Traverse the edges of all member triangles and discard any edges that appear twice.
        members.forEach((member, d) => {
            if (!member) return;
            for (let i = 0; i < 3; i++) {
                var e = [
                    delaunay.triangles[3 * d + i],
                    delaunay.triangles[3 * d + ((i + 1) % 3)]
                ].sort();
                (edges[e[0]] = edges[e[0]] || []).push(e[1]);
                (edges[e[1]] = edges[e[1]] || []).push(e[0]);
                const k = e.join(":");
                if (counts[k]) delete counts[k];
                else counts[k] = 1;
            }
        });

        while (1) {
            let k = null;
            // Pick an arbitrary starting point on a boundary.
            for (k in counts) break;
            if (k == null) break;
            result.push((r = k.split(":").map(Number)));
            delete counts[k];
            let q = r[1];
            while (q != r[0]) {
                let p = q,
                    qs = edges[p],
                    n = qs.length;
                for (let i = 0; i < n; i++) {
                    q = qs[i];
                    let edge = [p, q].sort().join(":");
                    if (counts[edge]) {
                        delete counts[edge];
                        r.push(q);
                        break;
                    }
                }
            }
        }
        return result;
    }

    let alphahull = boundary(delaunay, alphashape)

    let t_h = []
    let t = []

    //alphahull.forEach(d => console.log(d))

    console.log(delaunay.triangles)

    //alphashape.forEach(e=> t.push(delaunay.trianglePolygon(e)))

    let included = []
    let all = []

    // for(let i = 0; i< alphashape.length; i++){
    //     if (alphashape[i] == 1){
    //         included.push(delaunay.trianglePolygon(delaunay.triangles[i]))
    //     }
    //     all.push(delaunay.trianglePolygon(delaunay.triangles[i]))
    //
    // }

    // let p_ = ['M 10 10 L 50 50']

    let paths = []

    t_h.forEach(function (d) {
        paths.push(`M ${d[0][0]} ${d[0][1]} L ${d[1][0]} ${d[1][1]}`)
        paths.push(`M ${d[1][0]} ${d[1][1]} L ${d[2][0]} ${d[2][1]}`)
        paths.push(`M ${d[2][0]} ${d[2][1]} L ${d[3][0]} ${d[3][1]}`)

    });
    console.log(delaunay.trianglePolygons())
    //delaunay.trianglePolygons().forEach(d=>console.log(d))


    delaunay.triangles.forEach(d=> all.push(delaunay.trianglePolygon(d)))

    let paths_2 = []

    all.forEach(function (d) {
        paths_2.push(`M ${d[0][0]} ${d[0][1]} L ${d[1][0]} ${d[1][1]}`)
        paths_2.push(`M ${d[1][0]} ${d[1][1]} L ${d[2][0]} ${d[2][1]}`)
        paths_2.push(`M ${d[2][0]} ${d[2][1]} L ${d[3][0]} ${d[3][1]}`)

    });

    // paths_2.push('M 5 5 L 500 500')

    let svg = d3.select("body")
        .append("svg")
        .attr("width", w)
        .attr("height", h)
        .attr("class", "Blues");

    svg.append("g")
        .selectAll("circle")
        .data(data)
        .enter().append("circle")
        .attr("r", 3)
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

    svg.append("g")
        .selectAll(".a_shape")
        .data(paths_2)
        .enter().append('path')
        .attr('d', d=>d)
        .attr('stroke', 'black')
        .attr('class','a_shape')

    // svg.append("g")
    //     .selectAll("path")
    //     .data(paths)
    //     .enter().append('path')
    //     .attr('d', d=>d)
    //     .attr('stroke', 'red')






    //function distance(a,b){ return Math.sqrt(Math.pow(a,2) + Math.pow(b,2))}

    // delaunay.trianglePolygon(delaunay.triangles[0]).forEach(d => console.log(distance(d[0],d[1])))

    // console.log(delaunay.triangles[0])
    //
    // console.log(delaunay)





    // const segments = delaunay.triangles.slice(1);
    // let i = 0;
    // for (const e of segments) {
    //     context.beginPath();
    //     context.strokeStyle = d3.hsl(360 * Math.random(), 0.7, 0.5);
    //     context.stroke(new Path2D("M" + e));
    // }


    //delaunay.render(delaunay.trianglePolygon(delaunay.triangles[0]))
    // const segments = voronoi.render().split(/M/).slice(1);
    // let i = 0;
    // for (const e of segments) {
    //     context.beginPath();
    //     context.strokeStyle = d3.hsl(360 * Math.random(), 0.7, 0.5);
    //     context.stroke(new Path2D("M" + e));
    // }
    // no yield context.canvas; as we're not on a generator

    document.querySelector("#app").appendChild(canvas);


</script>
</body>
</html>